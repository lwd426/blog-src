title: 就看它就够了！学习笔记--自己对构造函数、原型和实例最深刻的理解 
date: 2013-07-09 12:10:09
tags:
- javascript
- 自己的笔记
categories: 基础

---

自己总算是把JS中那些错综复杂的各种对象、函数、原型以及基于原型继承的原理搞清楚了。以下是自己做的笔记

用简单的语言描述下js中构造函数、实例对象和原型的关系：

### 实例化的过程就是：

1. 先建立一个空对象
2. 让这个空对象的_proto_属性指向构造函数的原型对象，
3. 然后执行 构造函数.apply(空对象)，
4. 最后返回这个对象（已经不是空的了，有私有属性了）

### 由这个过程可以看出

1. 构造函数可以只是一个函数，它的作用就是实例化一个实例对象。还有就是他有一个原型对象。
2. 实例：可以这样理解，它**只是一个与原构造函数平行的、与之共有同一个原型对象的函数。**
3. 实例化对象一旦完成实例化，跟构造函数就再无瓜葛了。
4. 同一个构造函数实例化出的几个对象也都是独立的。它们唯一的联系就是都有一个_proto_指向同一个原型对象。
5. 如果想给一个实例对象添加私有属性和方法，直接点加;
6. 如果想给所有的实例对象添加共有方法或属性，在原型对象（构造函数.prototype）中点加。
7. 所有的函数都有原型对象O.prototype
8. **重要：让一个对象继承另一个对象，只需要让两者基于共同的原型，然后调用apply来有共同的私有属性，与父子没有一点关系！！！**
	
<!-- more -->

### 理论联合实际

*按照这个结论就可以解释为什么把arguments这个类数组对象转成数组对象时用Array.prototype.slice.apply(arguments)而不用Array.slice了。*

因为Array对象也只是个方法(console.log(Array)
打印出来的是Function [Array])，它的方法都定义在了它的原型Array.prototype上了(为了节省资源，让数组实例拥有同一个原型，同一套方法，而不是每个实例自己一套)。所以Array.slice是undefined

### 换一种说法

*原型继承的基础是原型链查找。*

原型链查找基本概念：

1. 每一个函数 F 都有一个原型对象（prototype）F.prototype
2. 每一个函数都可以通过 new 关键字化身成为一个类构造函数，new F 会产生一个对象 O
3. 在调用对象的某个属性或者方法，比如 O.xxx 的时候，会首先查找对象自身是否有这个方法或者属性，如果没找到就会去对象的构造函数的原型对象中查找（注意有两个定语），也就是查找 O 的构造函数 F 的原型对象 F.prototype.xxx
4. F.prototype 也是一个对象，查找F.prototype.xxx 的时候会重复第 3 步的过程

首先，要明确几个点：

1. 在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。

2. 方法(Function)
	方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。

![](/images/objectAndPrototype.jpg)

好啦，知道了这两个基本点，我们来看看上面这副图。

1. 构造函数Foo()
构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。

2. 原型对象Foo.prototype
Foo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。

3. 实例
f1和f2是Foo这个对象的两个实例，这两个对象也有属性__proto__，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。

另外：

构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？

指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。

其实除了Foo()，Function(), Object()也是一样的道理。

原型对象也是对象啊，它的__proto__属性，又指向谁呢？
同理，指向它的构造函数的原型对象呗。这里是Object.prototype.

最后，Object.prototype的__proto__属性指向null。

总结：
1.对象有属性__proto__,指向该对象的构造函数的原型对象。
2.方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。
http://www.zhihu.com/question/34183746/answer/58155878