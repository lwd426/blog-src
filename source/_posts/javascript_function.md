title: 自己对“闭包”的理解
date: 2013-03-04 08:45:20
tags: 
- javascript
categories: 基础

---

>当我不在把javascipt仅仅当成玩具去完成前端页面的特效时，那么就是时候来真正了解闭包是什么了。

### 基础概念
首先要知道以下几个概念：

* 上下文环境
* 全局变量和局部变量
* javascript的参数和返回值都可以是函数
* 函数内部的方法可以访问到函数的局部变量和全局变量
* 函数内部的方法访问的变量是不会随着外部函数的销毁而销毁的，知道内部函数也销毁了
<!-- more -->
知道以上几个基本概念以后，就可以清楚的知道什么是闭包了。

### 闭包的定义
>引用阮一峰老师一篇日志：
>
>各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，`闭包就是能够读取其他函数内部变量的函数`。
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成`"定义在一个函数内部的函数"`。
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

综上所述，闭包最终定义为：
`闭包就是定义在一个函数内部、能够读取其他函数内部变量的函数`


### 实例讲解

>ps: 由于阮一峰老师的例子真的很有代表性，而且很清晰，就直接引用了。

```javascript
   function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
```
在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。

为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。

### 闭包的用途

闭包可以用在许多地方。它的最大用处有以下几个：

1. 前面提到的可以读取函数内部的变量
2. 让这些变量的值始终保持在内存中
3. 用途2的更高级用途就是高阶函数中的偏函数的使用：
   >偏函数：指创建一个调用另外一个部分---参数或变量已经预知的函数---的函数的用法.直白说就是： 通过闭包来创建预先填写好的某些参数的函数." 可以通过这个来创建动态名称的函数，看起来应该很牛B，代码可读性也更好"
   
	```javascript
   function suffix(a){
      return function(b){
         return [b, a].join(' ');
      }
    }

    var hello = suffix("world");
　/*  等同于
　　　function hello (b){
　　　　　return [b,"world"].join();
　　　}
　* */

    console.log(hello("hello")); // hello world   ```

### 使用时的注意事项

1. `在退出函数之前，将不使用的局部变量全部删除`：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。。
2. `闭包尽量不要改变外部函数的私有变量`：闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
